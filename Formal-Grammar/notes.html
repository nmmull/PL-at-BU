<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-10-21 Mon 14:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Formal Grammar</title>
<meta name="author" content="Nathan  Mull" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../myStyle.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '2em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '2em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up"><a href="../toc.html">↩</a></div><div id="content" class="content">
<h1 class="title">Formal Grammar</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org875928f">Introduction</a></li>
<li><a href="#org5b43dca">Backus-Naur Form</a>
<ul>
<li><a href="#orgb464740">Definitions</a></li>
<li><a href="#orga46734b">A More Interesting Example</a></li>
<li><a href="#org3f3d53d">Parse Trees</a></li>
</ul>
</li>
<li><a href="#org92cc265">Ambiguity</a>
<ul>
<li><a href="#orgc040f0f">Avoiding Ambiguity</a></li>
<li><a href="#orgc550ed5">Associativity</a></li>
<li><a href="#orgf000be4">Precedence</a></li>
<li><a href="#org3348eb1">Parentheses (Again)</a></li>
</ul>
</li>
<li><a href="#org9f37264">Extended BNF</a>
<ul>
<li><a href="#org3c33293">Optional</a></li>
<li><a href="#orgaf5667b">Alternative</a></li>
<li><a href="#org8672d52">Repetition</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Before discussing parsing, we have to look at its mathematical
counterpart: <i>formal language theory</i>.  We won't put heavy emphasis on
formal language theory in this course (as interesting as it is);
rather the most important thing to get from these notes are:
</p>

<ul class="org-ul">
<li>the terminology, you need to know what a grammar is, what precedence is, etc.</li>
<li>the ability to <b>read</b> a grammar and (in time) construct a parser
from it using a parser generator</li>
</ul>

<p>
In particular, the problem of <b>designing</b> grammars is a subtle and
difficult one, and certainly one worth studying if you're interested.
But, logistically speaking, in this course you will be <i>given</i> a
grammar, from which you will generate a parser.
</p>

<div id="outline-container-org875928f" class="outline-2">
<h2 id="org875928f">Introduction</h2>
<div class="outline-text-2" id="text-org875928f">
<p>
Most of us are familiar with grammar in the context of natural
language.  In English class, we learn that we should use the article
"an" instead of "a" if its corresponding noun starts with a vowel
sound, and that what follows a semicolon should be a independent
clause (i.e., should be able to stand on its own as a complete
sentences).  These are examples of English <i>grammar rules</i>.
</p>

<p>
Grammar, in broad strokes, refers to the rules which govern what
constitutes a well-formed sentence in a given language, barring
low-level syntactic concerns like spelling or whitespace.  It's the
concern of grammar to determine that
</p>


<div class="org-src-container">
<pre class="src src-sentence">I taught the car in the refrigerator
</pre>
</div>

<p>
makes grammatical sense and that
</p>

<div class="org-src-container">
<pre class="src src-sentence">I car teach refrigerator in there
</pre>
</div>

<p>
does not.  It's <i>not</i> the concern of grammar to determine that the
first sentence, though grammatical, has no reasonable interpretation
in English (except, perhaps, in surrealist fiction).
</p>

<p>
Programming languages──being themselves languages in their own right,
albeit more stringent ones than natural languages──have their own
grammars, i.e., rules for determining what counts as a well-formed
<i>program</i>.  Due to the grammatic precision expected of programming
languages (we don't want too much variation in what we are allowed to
write as a valid program), these tend to be called <b>formal grammars</b>.
</p>

<blockquote>
<p>
<b>Example.</b> In OCaml, the program
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">f</span> <span style="color: #a0522d;">x</span> = x + 1
</pre>
</div>

<p>
is well-formed, but the program
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">f</span> <span style="color: #a0522d;">x</span> = x 1 +
</pre>
</div>

<p>
is not, because the rule for using the <code>+</code> operator is that its
arguments appear to its left and its right, i.e., it's an <i>infix
operator</i>.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>
</blockquote>

<p>
As in the case of natural language, grammars for programming languages
are not concerned with the <b>meaning</b> of programs, just their
well-formedness. The program
</p>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">omega</span> <span style="color: #a0522d;">x</span> = x x
</pre>
</div>

<p>
is well-formed in OCaml, but it's not well-typed since the argument
<code>x</code> is expected to be a function of type <code>'a -&gt; 'b</code> as well as an
argument of type <code>'a</code>, an impossibility in the type system of OCaml.
</p>

<p>
If our goal is to interpret computer programs, then we have to
understand formally──both theoretically and practically──the grammars
describing the well-formed programs.  This means being able to
represent and interpret representations of formal grammars.  The
grammar of OCaml, for example, is given in its entirety in <a href="https://v2.ocaml.org/manual/expr.html">The OCaml
Manual</a>.  After going through this chapter, you should be able to
interpret the specification given there.
</p>

<p>
Placing this in the pipeline of interpretation, a grammar represents
the target of <i>parsing</i>.  As a reminder, a stream of tokens is parsed
into a <b>parse tree</b>, a hierarchical structure which describes the way
the program is formally composed.  It's easier to determine the meaning
of a program (i.e., to interpret it) given its hierarchical structure
as opposed to its linear form as a stream of tokens.
</p>

<blockquote>
<p>
<b>Remark.</b> This is another way of conceptualizing the role of grammar:
it determines the hierarchical structure of a sentence.  A sentence
may be considered well-formed if it can constructed as well-formed
parse tree, e.g.
</p>

<div class="org-src-container">
<pre class="src src-ascii">S
├──┐
NP VP
│  ├──────┐
N  V      NP
│  │      ├───────┐
│  │      NP      PP
│  │      ├───┐   ├──┐
│  │      A   N   P  NP
│  │      │   │   │  ├───┐
│  │      │   │   │  A   N
│  │      │   │   │  │   │
I  taught the car in the refrigerator.
</pre>
</div>
</blockquote>

<p>
Its not important that you know exactly what you each of the
abbreviations in the above image stand for (this isn't a linguistics
course, but hopefully we can make educated guesses) but hopefully the
structure aligns with your intuition about how words in the sentences
are grouped.
</p>

<p>
In this collection of notes on formal grammars, we will:
</p>

<ul class="org-ul">
<li>define <b>Backus-Naur Form</b> specifications, a way of describing
so-called <b>context-free grammars</b>, which we will use to present the
grammars of programming languages;</li>
<li>discuss <b>ambiguity</b> in grammar along with how to avoid it (and why);</li>
<li>Look at <b>Extended BNF</b> as a slightly more useful framework for
specifying programming languages.</li>
</ul>
</div>
</div>

<div id="outline-container-org5b43dca" class="outline-2">
<h2 id="org5b43dca">Backus-Naur Form</h2>
<div class="outline-text-2" id="text-org5b43dca">
<p>
Backus-Naur Form (BNF) specifications are used to describe what are
called <b>context-free grammars</b>.  Context-free grammars form a class of
formal grammars which are sufficiently expressive to capture the
grammars of most programming languages.  We will be using BNF
specifications to describe the rules which determine well-formed
programs in programming languages we aim to interpret.
</p>

<p>
First, a toy example/thought experiment.  Consider the following
English statement.
</p>

<div class="org-src-container">
<pre class="src src-sentence">the cow jumped over the moon
</pre>
</div>

<p>
Suppose we tried to break down the cognitive process of determining
that this sentence is grammatical.  We might first recognize that each
word falls into a particular part of speech.  We can represent this
step of the process by replacing each word in the sentence with a
symbol <i>standing for</i> each figure of speech (the choice of symbol
being influenced by what is to come).
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
</pre>
</div>

<p>
We then might recognize some familiar patterns: <code>&lt;article&gt; &lt;noun&gt;</code>
captures the determination or quantification of an object, so we might
mentally group these symbols (into what grammaticists call <b>nominal
phrases</b> or <b>noun phrases</b>) and represent them by a new symbol:
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">noun-phrase</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">noun-phrase</span>&gt;
</pre>
</div>

<p>
Then we might recognize that a preposition followed by a noun phrase
is also single unit ("over the moon", "through the woods", and "behind
the wall" are examples of <b>prepositional phrases</b>) so that the
structure of the entire sentence may be represented as
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">noun-phrase</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep-phrase</span>&gt;
</pre>
</div>

<p>
Then we might recognize that prepositional phrases can modify verbs,
again creating a single unit (e.g., "ran to the car", "arose from
bed") leaving us with something like
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">noun-phrase</span>&gt; &lt;<span style="color: #483d8b;">verb-phrase</span>&gt;
</pre>
</div>

<p>
which we should finally recognize the canonical structure of a
well-formed sentence: <i>a thing does a thing.</i> A bit hand-wavy, but
this accounts roughly for what we do when we judge that the above
sentence is grammatical.
</p>

<p>
Putting these steps in reverse order (and starting with a single
symbol <code>&lt;sentence&gt;</code>) we get something that looks like a <i>proof</i> that
<code>the cow jumped over the moon</code> is a grammatical sentence.
</p>


<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">sentence</span>&gt;
&lt;<span style="color: #483d8b;">noun phrase</span>&gt;    &lt;<span style="color: #483d8b;">verb phrase</span>&gt;
&lt;<span style="color: #483d8b;">noun phrase</span>&gt;    &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep phrase</span>&gt;
&lt;<span style="color: #483d8b;">noun phrase</span>&gt;    &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">noun phrase</span>&gt;
&lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
the       cow    jumped over   the       moon
</pre>
</div>

<p>
That is, a representation of our congnitive process.  And if we
squint, we can see something that hierarchical, something that looks a
bit like the parse tree in the introduction to this chapter.
</p>

<div class="org-src-container">
<pre class="src src-tree">S
├───────┐
NP      VP
├───┐   ├──────┐
A   N   V      PP
│   │   │      ├────┐
│   │   │      P    NP
│   │   │      │    ├───┐
│   │   │      │    A   N
│   │   │      │    │   │
the cow jumped over the moon
</pre>
</div>

<p>
A <b>formal grammar</b> is meant to model this cognitive process of
classifying a sentence as grammatical by verifying that it has the
"right" hierarchical structure.
</p>
</div>

<div id="outline-container-orgb464740" class="outline-3">
<h3 id="orgb464740">Definitions</h3>
<div class="outline-text-3" id="text-orgb464740">
<p>
When defining a formal grammar, we fix ourselves to a collection of
symbols.  These symbols are divided into two disjoint groups: the
<b>terminal symbols</b> and the <b>non-terminal symbols</b>.  We will always
notate a non-terminal symbol by something of the form <code>&lt;non-term&gt;</code>
(where we replace <code>non-term</code> with something more descriptive) and
terminal symbols by sequence of (typically) alphanumeric symbols.
</p>

<blockquote>
<p>
<b>Remark.</b> We almost never state outright what the underlying symbols
of a grammar are.  It should always be possible to determine what
terminal and non-terminal symbols we are considering by looking at the
BNF specification itself.
</p>
</blockquote>

<p>
In the proof that <code>the cow jumped over the moon</code> was grammatical, we
built a sequence of not-quite sentences, until the very last one which
was an actual sentences. We call these not-quite sentences <b>sentential
forms</b>.
</p>

<blockquote>
<p>
<b>Definition.</b> A <b>sentential form</b> is a sequence of symbols (terminal
or non-terminal).  A <b><b>sentence</b></b> is a sequence of terminal symbols.
</p>
</blockquote>

<blockquote>
<p>
<b>Remark.</b> We notate a sequences of symbols by white space separation.
For example,
</p>

<div class="org-src-container">
<pre class="src src-sent">the dog jumped
</pre>
</div>

<p>
is a sentence and
</p>

<div class="org-src-container">
<pre class="src src-bnf">the &lt;<span style="color: #483d8b;">noun</span>&gt; jumped
</pre>
</div>

<p>
is a sentential form.  But it is important to note that <i>this is just
notation</i>.  If it helps, it may be useful to imagine a <i>list</i>
</p>

<div class="org-src-container">
<pre class="src src-sent">[the; &lt;noun&gt;; jumped]
</pre>
</div>

<p>
when thinking about what a sentential form is.
</p>
</blockquote>

<p>
In the process of building sentential forms, we replaced non-terminal
symbols with sentential forms, e.g., we replaced <code>&lt;noun phrase&gt;</code> with
<code>&lt;article&gt; &lt;noun&gt;</code>.  A grammar is determined by what replacements we
are allowed to do.
</p>

<blockquote>
<p>
<b>Definition.</b> A <b>production rule</b> is an equation of the form
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">non-term</span>&gt; <span style="color: #008b8b;">::=</span> SENTENTIAL-FORM
</pre>
</div>

<p>
where the left-hand side of the <code>::=</code> is a non-terminal symbol, and
the right-hand side is a sentential form.
</p>
</blockquote>

<p>
We read a production rule as: "the non-terminal symbol on the
left-hand side can be replaced with the sentential form on the right
hand side."  In a sense, production rules <i>define</i> the non-terminal
symbols, e.g., a sentence is a noun phrase followed by a verb phrase.
</p>

<blockquote>
<p>
<b>Definition.</b> A <b>Backus-Naur Form (BNF) specification</b> is a collection
of production rules, together with a designated the <b>starting symbol</b>.
</p>
</blockquote>


<p>
We will always take the start symbol will be designated as the
left-hand side of the <b>first</b> rule appearing in a specification.
</p>

<blockquote>
<p>
<b>Example.</b> The following is an example of a grammar which <i>recognizes</i>
the sentence above.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">sentence</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">noun-phrase</span>&gt; &lt;<span style="color: #483d8b;">verb-phrase</span>&gt;
&lt;<span style="color: #0000ff;">verb-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep-phrase</span>&gt;
&lt;<span style="color: #0000ff;">verb-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">verb</span>&gt;
&lt;<span style="color: #0000ff;">prep-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">noun-phrase</span>&gt;
&lt;<span style="color: #0000ff;">noun-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
&lt;<span style="color: #0000ff;">article</span>&gt;     <span style="color: #008b8b;">::=</span> the
&lt;<span style="color: #0000ff;">noun</span>&gt;        <span style="color: #008b8b;">::=</span> cow
&lt;<span style="color: #0000ff;">noun</span>&gt;        <span style="color: #008b8b;">::=</span> moon
&lt;<span style="color: #0000ff;">verb</span>&gt;        <span style="color: #008b8b;">::=</span> jumped
&lt;<span style="color: #0000ff;">prep</span>&gt;        <span style="color: #008b8b;">::=</span> over
</pre>
</div>

<p>
The nonterminal symbol <code>&lt;sentence&gt;</code> is our starting symbol because it
appears as the left-hand side of the first rule.
</p>
</blockquote>

<p>
Note that a non-terminal symbol can have multiple associated
production rules.  This is common enough that we have special syntax
for this.
</p>

<blockquote>
<p>
<b>Notation.</b> We write
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">non-term</span>&gt; <span style="color: #008b8b;">::=</span> SENT-FORM-1 <span style="color: #ff0000; font-weight: bold;">|</span> SENT-FORM-2 <span style="color: #ff0000; font-weight: bold;">|</span> ... <span style="color: #ff0000; font-weight: bold;">|</span> SENT-FORM-n
</pre>
</div>

<p>
as shorthand for
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">non-term</span>&gt; <span style="color: #008b8b;">::=</span> SENT-FORM-1
&lt;<span style="color: #0000ff;">non-term</span>&gt; <span style="color: #008b8b;">::=</span> SENT-FORM-2
...
&lt;<span style="color: #0000ff;">non-term</span>&gt; <span style="color: #008b8b;">::=</span> SENT-FORM-n
</pre>
</div>
</blockquote>

<p>
With this shorthand, we can write the above grammar as:
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">sentence</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">noun-phrase</span>&gt; &lt;<span style="color: #483d8b;">verb-phrase</span>&gt;
&lt;<span style="color: #0000ff;">verb-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">verb</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep-phrase</span>&gt;
&lt;<span style="color: #0000ff;">prep-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">noun-phrase</span>&gt;
&lt;<span style="color: #0000ff;">noun-phrase</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
&lt;<span style="color: #0000ff;">article</span>&gt;     <span style="color: #008b8b;">::=</span> the
&lt;<span style="color: #0000ff;">noun</span>&gt;        <span style="color: #008b8b;">::=</span> cow <span style="color: #ff0000; font-weight: bold;">|</span> moon
&lt;<span style="color: #0000ff;">verb</span>&gt;        <span style="color: #008b8b;">::=</span> jumped
&lt;<span style="color: #0000ff;">prep</span>&gt;        <span style="color: #008b8b;">::=</span> over
</pre>
</div>

<p>
The last piece of the thought experiment above that we need to
formalize is the <i>proof</i> that the given sentence was grammatical.  We
formalize this in the notion of a <b>derivation</b>.
</p>

<blockquote>
<p>
<b>Definition.</b> A <b>derivation</b> of a sentence <code>S</code> in a BNF grammar is a
sequence of sentential forms with the following properties:
</p>

<ul class="org-ul">
<li>it beginning with the designated start symbol;</li>
<li>it ends in the sentence <code>S</code>;</li>
<li>each sentential form is a the result of replacing <i>one of</i> the
non-terminal symbols in the preceding sentence with a sentential
form according to a production rule of the grammar.</li>
</ul>

<p>
We say that a grammar <b>recognizes</b> a sentence <code>S</code> if there is a
derivation of <code>S</code> in the grammar.
</p>
</blockquote>

<p>
This definition restates the process from the thought experiment
mathematically.  That said, it deviates in one way which makes the
definition easier to state: in the thought experiment, we allowed
ourselves to replace multiple non-terminal symbols simultaneously.
This is not allowed in the above notion of a derivation. A <i>correct</i>
derivation would look like:
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">sentence</span>&gt;
&lt;<span style="color: #483d8b;">noun-phrase</span>&gt;    &lt;<span style="color: #483d8b;">verb-phrase</span>&gt;
&lt;<span style="color: #483d8b;">noun-phrase</span>&gt;    &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep-phrase</span>&gt;
&lt;<span style="color: #483d8b;">noun-phrase</span>&gt;    &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">noun-phrase</span>&gt;
&lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">noun-phrase</span>&gt;
&lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
the       &lt;<span style="color: #483d8b;">noun</span>&gt; &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
the       cow    &lt;<span style="color: #483d8b;">verb</span>&gt; &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
the       cow    jumped &lt;<span style="color: #483d8b;">prep</span>&gt; &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
the       cow    jumped over   &lt;<span style="color: #483d8b;">article</span>&gt; &lt;<span style="color: #483d8b;">noun</span>&gt;
the       cow    jumped over   the       &lt;<span style="color: #483d8b;">noun</span>&gt;
the       cow    jumped over   the       moon
</pre>
</div>

<blockquote>
<p>
<b>Exercise.</b> In the above derivation, mark the nonterminal in each
sentential form which was replaced in the following line.
</p>
</blockquote>

<p>
A sentence is not guaranteed to have a <i>unique</i> derivation.  There are
two forms of derivations that will be of particular importance for us.
</p>

<blockquote>
<p>
<b>Definition.</b> A <b>leftmost derivation</b> of a sentence is one in which
the leftmost nonterminal symbol is expanded in each step.  A
<b>rightmost derivation</b> is one in which the rightmost nonterminal
symbol is expanded in each step.
</p>
</blockquote>


<p>
Note that the above derivation is neither the leftmost derivation or
the rightmost derivation.
</p>

<blockquote>
<p>
<b>Exercise.</b> Write leftmost and rightmost derivations for the sentence
</p>

<div class="org-src-container">
<pre class="src src-sent">the cow jumped over the moon
</pre>
</div>

<p>
in the above grammar.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orga46734b" class="outline-3">
<h3 id="orga46734b">A More Interesting Example</h3>
<div class="outline-text-3" id="text-orga46734b">
<p>
The following is a BNF specification for a fragment of a simple
imperative programming language.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">program</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">stmts</span>&gt;
&lt;<span style="color: #0000ff;">stmts</span>&gt;   <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">stmt</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">stmt</span>&gt; <span style="color: #b22222;">; &lt;stmts&gt;</span>
&lt;<span style="color: #0000ff;">stmt</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">var</span>&gt;     <span style="color: #008b8b;">::=</span> a <span style="color: #ff0000; font-weight: bold;">|</span> b <span style="color: #ff0000; font-weight: bold;">|</span> c <span style="color: #ff0000; font-weight: bold;">|</span> d
&lt;<span style="color: #0000ff;">expr</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">term</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">term</span>&gt; + &lt;<span style="color: #483d8b;">term</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">term</span>&gt; - &lt;<span style="color: #483d8b;">term</span>&gt;
&lt;<span style="color: #0000ff;">term</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> const
</pre>
</div>

<p>
In English, we would read this specification as:
</p>

<ul class="org-ul">
<li>a PROGRAM is a SEQUENCE OF STATEMENTS;</li>
<li>a SEQUENCE OF STATEMENTS is either a single STATEMENT, or a single
STATEMENT followed a semicolon, followed by a SEQUENCE OF
STATEMENTS;</li>
<li>a STATEMENT is a VARIABLE followed by an equals sign, followed
by an EXPRESSION.</li>
</ul>

<p>
and so on.
</p>

<p>
This second rule highlights something interesting which we can do in
BNF specifications: rules are allowed to be <i>recursive</i>.  The
production rule for <code>&lt;stmts&gt;</code> allows us to replace it with a
sentential form which <i>contains</i> the non-terminal symbol <code>&lt;stmts&gt;</code>.
This is quite powerful, particularly because it means it is possible
to derive an infinite number of sentences in a given grammar.
</p>

<blockquote>
<p>
<b>Exercise.</b> Determine the number of sentences that can be derived in
 the grammar from the previous section (i.e., the number of sentences
 which can be derived from the starting symbol <code>&lt;sentence&gt;</code>).
</p>
</blockquote>

<p>
Consider the following program.
</p>

<div class="org-src-container">
<pre class="src src-prog">a = const ;
a = a + const ;
b = a
</pre>
</div>

<p>
We can verify that this program is recognized by the above grammar by
finding a (leftmost) derivation.
</p>

<div class="org-src-container">
<pre class="src src-deriv">&lt;program&gt;
&lt;stmts&gt;
&lt;stmt&gt; ; &lt;stmts&gt;
&lt;var&gt; = &lt;expr&gt; ; &lt;stmts&gt;
a = &lt;expr&gt; ; &lt;stmts&gt;
a = &lt;term&gt; ; &lt;stmts&gt;
a = const ; &lt;stmts&gt;
a = const ; &lt;stmt&gt; ; &lt;stmts&gt;
a = const ; &lt;var&gt; = &lt;expr&gt; ; &lt;stmts&gt;
a = const ; a = &lt;expr&gt; ; &lt;stmts&gt;
a = const ; a = &lt;term&gt; + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = &lt;var&gt; + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = a + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = a + const ; &lt;stmts&gt;
a = const ; a = a + const ; &lt;var&gt; = &lt;expr&gt;
a = const ; a = a + const ; b = &lt;expr&gt;
a = const ; a = a + const ; b = &lt;term&gt;
a = const ; a = a + const ; b = &lt;var&gt;
a = const ; a = a + const ; b = a
</pre>
</div>

<blockquote>
<p>
<b>Remark.</b> As a reminder, we're not interested in white space when we
consider whether or not a sentence is recognized by a grammar.  The
choice to present the sentences in three lines was for readability,
and the choice to present it in a single line in the derivation was
for convenience.
</p>
</blockquote>

<p>
One notable feature of the last four lines of the above derivation:
even if a nonterminal symbol is replaced by a <i>single</i> nonterminal
symbol in succession, <b>we have to include each step</b>.  We're only
allowed to apply one production rule at a time, e.g., we cannot
immedatiely replace <code>&lt;expr&gt;</code> with <code>&lt;var&gt;</code> because that is not one of
our production rules.
</p>

<blockquote>
<p>
<b>Exercise.</b> Write a rightmost derivation for the above program.
</p>
</blockquote>

<blockquote>
<p>
<b>Exercise.</b> Verify that
</p>

<div class="org-src-container">
<pre class="src src-prog">a = a + a ; b = b
</pre>
</div>

<p>
is recognized by the above grammar.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org3f3d53d" class="outline-3">
<h3 id="org3f3d53d">Parse Trees</h3>
<div class="outline-text-3" id="text-org3f3d53d">
<p>
Grammars imbue sentences with hierarchical structure.  This structure
is represented graphically as a <b>parse tree</b>.  We've seen a couple
examples of English grammar parse trees so far, but we can also build
parse trees for sentences recognized by <i>any</i> grammar with a BNF
specification.
</p>

<blockquote>
<p>
<b>Definition.</b> A <b>parse tree</b> for a sentence <code>S</code> in a grammar is a tree
<code>T</code> with the following properties:
</p>

<ul class="org-ul">
<li>every leaf of <code>T</code> has a terminal symbol;</li>
<li>every non-leaf node <code>n</code> has a nonterminal symbol (we write <code>val(n)</code>
for the value at <code>n</code>);</li>
<li><p>
if a node <code>n</code> with has children <code>[t1, t2, ..., tk]</code> then
</p>

<div class="org-src-container">
<pre class="src src-pseudo">val(n) ::= root(t1) root(t2) ... root(tk)
</pre>
</div>

<p>
is a production rule in the grammar (where <code>root(t)</code> denotes the
value at the root of the tree <code>t</code>);
</p></li>

<li>the leaves (in order) (i.e., the <b>frontier</b> of <code>T</code>) form the
sentence <code>S</code>.</li>
</ul>
</blockquote>

<p>
The details of the above definition are not so important, as long as
you have the right picture in your head.  For example, the sentence <code>a
= b + const</code> has the following derivation.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">program</span>&gt;
&lt;<span style="color: #483d8b;">stmts</span>&gt;
&lt;<span style="color: #483d8b;">stmt</span>&gt;
&lt;<span style="color: #483d8b;">var</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
a = &lt;<span style="color: #483d8b;">expr</span>&gt;
a = &lt;<span style="color: #483d8b;">term</span>&gt; + &lt;<span style="color: #483d8b;">term</span>&gt;
a = &lt;<span style="color: #483d8b;">var</span>&gt; + &lt;<span style="color: #483d8b;">term</span>&gt;
a = b + &lt;<span style="color: #483d8b;">term</span>&gt;
a = b + const
</pre>
</div>

<p>
And has the following parse tree.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">program</span>&gt;
&#9474;
&lt;<span style="color: #483d8b;">stmts</span>&gt;
&#9474;
&lt;<span style="color: #483d8b;">stmt</span>&gt;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9488;
&lt;<span style="color: #483d8b;">var</span>&gt; &#9474;   &lt;<span style="color: #483d8b;">expr</span>&gt;
&#9474;     &#9474;   &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9488;
&#9474;     &#9474;   &lt;<span style="color: #483d8b;">term</span>&gt; &#9474; &lt;<span style="color: #483d8b;">term</span>&gt;
&#9474;     &#9474;   &#9474;      &#9474; &#9474;
&#9474;     &#9474;   &lt;<span style="color: #483d8b;">var</span>&gt;  &#9474; &#9474;
&#9474;     &#9474;   &#9474;      &#9474; &#9474;
a     =   b      + const
</pre>
</div>

<blockquote>
<p>
<b>Remark.</b> You don't have to draw your trees in this rectilinear
styling. If you're drawing one on paper, I'd recommend drawing it like
any other tree you've drawn for another computer science course.  I
just have a predilection for ASCII art&#x2026;
</p>
</blockquote>

<blockquote>
<p>
<b>Exercise.</b> Given the ADT
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a tree</span>
   = <span style="color: #000000; background-color: #ffffff;">Leaf</span> <span style="color: #a020f0;">of</span> 'a
   | <span style="color: #000000; background-color: #ffffff;">Node</span> <span style="color: #a020f0;">of</span> 'a * 'a tree list
</pre>
</div>

<p>
write the OCaml function <code>frontier</code> which, given
</p>

<ul class="org-ul">
<li><code>t</code> of type <code>'a tree</code></li>
</ul>

<p>
returns the list of leaves of <code>t</code> in order from left to right.
</p>
</blockquote>

<p>
Every derivation can be converted into a parse tree, and vice versa,
but multiple derivations may correspond to the same parse tree.  This
will be important when we cover ambiguity in the next section.
</p>

<blockquote>
<p>
<b>Exercise.</b> Write a derivation corresponding to the above parse tree
 when is neither leftmost nor rightmost.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org92cc265" class="outline-2">
<h2 id="org92cc265">Ambiguity</h2>
<div class="outline-text-2" id="text-org92cc265">
<p>
As participants of language, we are no strangers to grammatical
ambiguity.  Take, for instance, the following sentence:<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-sent">John saw the man on the mountain with the telescope
</pre>
</div>

<p>
Was John using the telescope?  Was the man carrying the telescope?
Are the multiple mountains, one of which has a telescope on it?
</p>

<p>
The ambiguity exists because it is not clear <i>which</i> hierarchical
structure should scaffold the sentence.  Here's a possible parse
trees for the sentence.
</p>

<div class="org-src-container">
<pre class="src src-ascii">S
├────┐
NP   VP
│    ├───┬───────────────────────┐
N    V   NP                      PP
│    │   ├───────┐               │
│    │   NP      PP              │
│    │   │       ├──┐            ├────┐
│    │   │       P  NP           P    NP
│    │   ├───┐   │  ├───┐        │    ├───┐
│    │   A   N   │  A   N        │    A   N
│    │   │   │   │  │   │        │    │   │
John saw the man on the mountain with the telescope
</pre>
</div>

<p>
The propositional phrase <code>with the telescope</code> is grouped alongside the
verb phrase starting with <code>saw</code>, indicating that John was <i>using</i> the
telescope.  Another option:
</p>


<div class="org-src-container">
<pre class="src src-ascii">S
├────┐
NP   VP
│    ├───┐
N    V   NP
│    │   ├───────┐
│    │   NP      PP
│    │   ├───┐   ├──┐
│    │   A   N   P  NP
│    │   │   │   │  ├────────────┐
│    │   │   │   │  NP           PP
│    │   │   │   │  ├───┐        ├────┐
│    │   │   │   │  A   N        P    NP
│    │   │   │   │  │   │        │    ├───┐
│    │   │   │   │  │   │        │    A   N
│    │   │   │   │  │   │        │    │   │
John saw the man on the mountain with the telescope
</pre>
</div>

<p>
The prepositional phrase <code>with the telescope</code> is part of the noun
phrase with <code>the mountain</code>, indicating the there is a telescope on the
mountain and the man is climbing that mountain.
</p>

<p>
The ambiguity comes from not being completely sure which parse tree to
give to the sentence; we experience language in a <i>linear fashion</i>,
either by reading it or hearing it.  If our interlocutor could
<i>display</i> the parse tree of their statement (floating eerily in space
before your eyes) there would be nothing to say of (grammatical)
ambiguity.
</p>

<p>
But this is <i>not</i> how we experience language, or how we write
programs for that matter.  To drive the point home, there is a
natural-enough looking grammar which recognizes the above sentence.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">s</span>&gt;  <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">np</span>&gt; &lt;<span style="color: #483d8b;">vp</span>&gt;
&lt;<span style="color: #0000ff;">vp</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">v</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">v</span>&gt; &lt;<span style="color: #483d8b;">np</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">v</span>&gt; &lt;<span style="color: #483d8b;">np</span>&gt; &lt;<span style="color: #483d8b;">pp</span>&gt;
&lt;<span style="color: #0000ff;">pp</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">p</span>&gt; &lt;<span style="color: #483d8b;">np</span>&gt;
&lt;<span style="color: #0000ff;">np</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">n</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">d</span>&gt; &lt;<span style="color: #483d8b;">n</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">np</span>&gt; &lt;<span style="color: #483d8b;">pp</span>&gt;
&lt;<span style="color: #0000ff;">n</span>&gt;  <span style="color: #008b8b;">::=</span> John <span style="color: #ff0000; font-weight: bold;">|</span> man <span style="color: #ff0000; font-weight: bold;">|</span> mountain <span style="color: #ff0000; font-weight: bold;">|</span> telescope
&lt;<span style="color: #0000ff;">v</span>&gt;  <span style="color: #008b8b;">::=</span> saw
&lt;<span style="color: #0000ff;">d</span>&gt;  <span style="color: #008b8b;">::=</span> the
&lt;<span style="color: #0000ff;">p</span>&gt;  <span style="color: #008b8b;">::=</span> on <span style="color: #ff0000; font-weight: bold;">|</span> with
</pre>
</div>

<p>
The above sentence has multiple parse trees in the above
grammar. Equivalently, since parse trees correspond to exactly one
leftmost derivation (you should try to convince yourself of this), it
also has multiple leftmost derivations.
</p>

<blockquote>
<p>
<b>Exercise.</b> Give two leftmost derivations of
</p>

<div class="org-src-container">
<pre class="src src-sent">John saw the man on the mountain with the telescope
</pre>
</div>

<p>
in the above grammar.
</p>
</blockquote>

<p>
Ambiguity in natural language is a complex topic, but restricted to
formal grammars, ambiguity is a well-defined notion.
</p>

<blockquote>
<p>
<b>Definition.</b> A grammar is <b>ambiguous</b> there is a sentence it
recognizes which has two distinct parse trees.  Equivalently, it is
ambiguous of there is a sentence it recognizes which has two distinct
leftmost derivations.
</p>
</blockquote>

<p>
Thus, the above grammar is ambiguous in the mathematical sense.
</p>

<p>
More to the point, consider the following grammar which may be seen as
a prototype of a grammar for arithmetic expressions (something we will
probably want if we're to give a grammar for a programming language).
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">op</span>&gt;   <span style="color: #008b8b;">::=</span> + <span style="color: #ff0000; font-weight: bold;">|</span> - <span style="color: #ff0000; font-weight: bold;">|</span> * <span style="color: #ff0000; font-weight: bold;">|</span> /
&lt;<span style="color: #0000ff;">var</span>&gt;  <span style="color: #008b8b;">::=</span> x
</pre>
</div>

<p>
This seems, ignoring obvious issues, a reasonable enough definition;
<i>an expression is either a variable or a pair of expressions with an
operator between them</i>.  Note that the recursive nature of the first
production rule means that this grammar recognizes an infinite number
of sentence.
</p>

<blockquote>
<p>
<b>Exercise.</b> Give a leftmost a derivation of <code>x * x + x * x</code> in the above grammar.
</p>
</blockquote>

<p>
But, with regards to ambiguity, we should already be suspicious of the
first production rule.  As soon as we've applied the (second
alternative of) the first production rule twice we have the partial derivation:
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
</pre>
</div>

<p>
For the third line, <i>which of the two <code>&lt;expr&gt;</code> symbols did we expand?</i>
To make this concrete, here are two parse trees for the sentence <code>x +
x + x</code>.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">expr</span>&gt;                                &lt;<span style="color: #483d8b;">expr</span>&gt;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9488;                         &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9488;
&lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;                    &lt;<span style="color: #483d8b;">expr</span>&gt;             &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&#9474;      &#9474;    &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9488;             &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9488;      &#9474;    &#9474;
&lt;<span style="color: #483d8b;">var</span>&gt;  &#9474;    &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;        &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; &#9474;    &lt;<span style="color: #483d8b;">var</span>&gt;
&#9474;      &#9474;    &#9474;      &#9474;    &#9474;             &#9474;      &#9474;    &#9474;      &#9474;    &#9474;
&#9474;      &#9474;    &lt;<span style="color: #483d8b;">var</span>&gt;  &#9474;    &lt;<span style="color: #483d8b;">var</span>&gt;         &lt;<span style="color: #483d8b;">var</span>&gt;  &#9474;    &lt;<span style="color: #483d8b;">var</span>&gt;  &#9474;    &#9474;
&#9474;      &#9474;    &#9474;      &#9474;    &#9474;             &#9474;      &#9474;    &#9474;      &#9474;    &#9474;
x      +    x      +    x             x      +    x      +    x
</pre>
</div>

<p>
These two parse trees correspond to the following two leftmost
derivations (the first for the tree on the left, the second for the
tree on the right).
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">var</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + &lt;<span style="color: #483d8b;">expr</span>&gt;
x + &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + &lt;<span style="color: #483d8b;">var</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + x &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + x + &lt;<span style="color: #483d8b;">expr</span>&gt;
x + x + &lt;<span style="color: #483d8b;">var</span>&gt;
x + x + x

&lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #483d8b;">var</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + &lt;<span style="color: #483d8b;">var</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + x &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
x + x + &lt;<span style="color: #483d8b;">expr</span>&gt;
x + x + &lt;<span style="color: #483d8b;">var</span>&gt;
x + x + x
</pre>
</div>


<p>
This demonstrates that the above grammar is ambiguous.
</p>

<blockquote>
<p>
<b>Aside.</b> In this example, and many of the examples we will see, it
will be fairly clear that the grammar is ambiguous.  As students of
computer science, we might think that we could write a <i>program</i> that
checks for us if a grammar is ambiguous.  Unfortunately, this is
impossible (not just very difficult, but <b>impossible</b>).  This is to
say that determining if a context-free grammar is ambiguous is
<b>undecidable</b> (a term worth looking up if this piques your
interest).
</p>
</blockquote>
</div>

<div id="outline-container-orgc040f0f" class="outline-3">
<h3 id="orgc040f0f">Avoiding Ambiguity</h3>
<div class="outline-text-3" id="text-orgc040f0f">
<p>
Our next task it to determine how to avoid this ambiguity, but first,
<i>why should we care?</i> Natural language is ambiguous and we get along
perfectly fine.  Why should we go through this trouble to make sure
grammars we design are unambiguous?
</p>

<p>
It's a fair question; the way I see it, it's something of a promise
that we make to the user of a programming language that we <b><b>never
make unspoken assumptions about what a user meant when we read one of
their programs.</b></b> To be fair, we try to do this with natural language
too, but in communication, if a statement is ambiguous, we can usually
just ask our interlocutor what they meant.  We can't do this for a
program, so instead we make it <i>impossible</i> for a sentence to have
multiple meanings.
</p>

<blockquote>
<p>
<b>Aside.</b> We see a similar phenomena in legal language, which tends to
 be grammatically sterile, and usually no fun to read.
</p>
</blockquote>
</div>

<div id="outline-container-orgffbd23e" class="outline-4">
<h4 id="orgffbd23e">(Reverse) Polish Notation</h4>
<div class="outline-text-4" id="text-orgffbd23e">
<p>
If our only concern is avoiding ambiguity, we can use <b>Polish
notation</b> or <b>reverse polish notation</b>.  In Polish notation, operators
appear <b>before</b> all their arguments, e.g.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">op</span>&gt;   <span style="color: #008b8b;">::=</span> + <span style="color: #ff0000; font-weight: bold;">|</span> - <span style="color: #ff0000; font-weight: bold;">|</span> * <span style="color: #ff0000; font-weight: bold;">|</span> /
&lt;<span style="color: #0000ff;">var</span>&gt;  <span style="color: #008b8b;">::=</span> x
</pre>
</div>

<p>
We won't dwell on this but it turns out this gives us an unambiguous
grammar, we don't even need parentheses.
</p>

<p>
It's not difficult to then guess what reverse polish notation is:
operators always appear <b>after</b> all their arguments.  This is how
early calculators like <a href="https://en.wikipedia.org/wiki/Hewlett-Packard_9100A">HP 9100A Desktop Calculator</a> were designed.  If
you wanted to calculate something <code>(2 + 3) * (4 - 5)</code>, you would
<i>push</i> the values you want to apply operations to onto a <b>stack</b>, and
then apply operations to the top elements of the stack, like so:
</p>

<div class="org-src-container">
<pre class="src src-rpn">STACK        RPN EXPRESSION
2            2
2 3          2 3
5            2 3 +
5 4          2 3 + 4
5 4 5        2 3 + 4 5
5 (-1)       2 3 + 4 5 -
(-5)         2 3 + 4 5 - *
</pre>
</div>

<p>
So the sequence of tokens you end up typing into the calculator is an
expression in reverse polish notation.
</p>

<blockquote>
<p>
<b>Exercise.</b> Derive the sentence
</p>

<div class="org-src-container">
<pre class="src src-rpn">+ * x * x - x x x x
</pre>
</div>

<p>
in the above grammar.
</p>
</blockquote>

<p>
The obvious issue with (reverse) polish notation is that it's
difficult to read.  Imagine working with a language in which
if-then-else logic had to be done like this:
</p>

<div class="org-src-container">
<pre class="src src-prog">IFTHENELSE
  cond
  IFTHENELSE
    IFTHENELSE
      cond
      ifcase
      elsecase
    ifcase
    elsecase
  elsecase
</pre>
</div>

<p>
This is in part to say that what truly causes ambiguity in expressions
is complex operator <b>fixity</b>.
</p>

<blockquote>
<p>
<b>Definition.</b> The <b>fixity</b> of an operator refers to where the
(syntactic components of an) operator is placed relative to its
arguments.  There are four kinds of operator fixity.
</p>
<ul class="org-ul">
<li>A <b>prefix</b> operator appears before its arguments. This is like
function application in OCaml, e.g.,
<ul class="org-ul">
<li><code>f x</code></li>
<li><code>not b</code></li>
</ul></li>
<li>A <b>postfix</b> operator appears after its arguments. This is like type
constructor application in OCaml, e.g.,
<ul class="org-ul">
<li><code>int list</code></li>
<li><code>bool option list</code></li>
</ul></li>
<li>An <b>infix</b> operator appears in between its arguments. This is like
arithmetic operations we learn in primary school, e.g.,
<ul class="org-ul">
<li><code>2 + 3</code></li>
<li><code>4 / 5</code></li>
</ul></li>
<li>A <b>mixfix</b> operator is an operator with multiple syntactic
components which may appear as some combination of prefix, infix and
postfix. This is like if-then-else expressions or anonymous
functions in OCaml, e.g.,
<ul class="org-ul">
<li><code>if b then x else y</code></li>
<li><code>fun x -&gt; e</code></li>
</ul></li>
</ul>
</blockquote>

<p>
If we want to contend with operator fixity (i.e., we don't want <b>just</b>
prefix or <b>just</b> postfix operators, as in polish notation or reverse
polish notation) then we have to work to avoid ambiguity.
</p>
</div>
</div>

<div id="outline-container-org236c5ea" class="outline-4">
<h4 id="org236c5ea">Parentheses</h4>
<div class="outline-text-4" id="text-org236c5ea">
<p>
Another simple solution is to surround applications of operations with
parentheses:
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> ( &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; )
&lt;<span style="color: #0000ff;">op</span>&gt;   <span style="color: #008b8b;">::=</span> + <span style="color: #ff0000; font-weight: bold;">|</span> - <span style="color: #ff0000; font-weight: bold;">|</span> * <span style="color: #ff0000; font-weight: bold;">|</span> /
&lt;<span style="color: #0000ff;">var</span>&gt;  <span style="color: #008b8b;">::=</span> x
</pre>
</div>

<p>
It then becomes very clear in a derivation like
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #483d8b;">expr</span>&gt;
( &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; )
( ( &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; ) &lt;<span style="color: #483d8b;">op</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt; )
</pre>
</div>

<p>
which <code>&lt;expr&gt;</code> in the second line we expanded.  But we run into a
similar issue: <i>lots of parentheses are no fun to read or type.</i>
</p>

<blockquote>
<p>
<b>Exercise.</b> Give a derivation of
</p>


<div class="org-src-container">
<pre class="src src-sent">( ( ( x * x ) * x ) + ( x / x ) )
</pre>
</div>

<p>
in the above grammar.
</p>
</blockquote>

<blockquote>
<p>
<b>Aside.</b> The cult of parentheses is real.  Programming languages based
on <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">LISP</a> use full parenthesization <i>and</i> prefix notation.  Many people
consider this to be elegant, and many others believe it to be ugly as
hell.
</p>
</blockquote>

<p>
So, our real basic question is: <i>how do we avoid grammar while being
able to mix operator fixities and not use so many parentheses?</i> And
this question has a simple answer in theory: <i>make explicit
assumptions about how operator arguments are grouped.</i> This will mean
contending with two things: <b>associativity</b> and <b>precedence</b>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc550ed5" class="outline-3">
<h3 id="orgc550ed5">Associativity</h3>
<div class="outline-text-3" id="text-orgc550ed5">
<p>
Associativity refers to how arguments are grouped when we are given a
sequence of applications of an infix operator in the absence of
parentheses, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-sent">x + x + x + x
</pre>
</div>

<p>
may be understood as any one of the following (among others):
</p>

<div class="org-src-container">
<pre class="src src-sent">(((x + x) + x) + x)
(x + (x + (x + x)))
((x + x) + (x + x))
(x + ((x + x) + x))
</pre>
</div>

<blockquote>
<p>
<b>Exercise.</b> Determine the number of ways the expression
</p>

<div class="org-src-container">
<pre class="src src-sent">x + x + x + x
</pre>
</div>

<p>
can be parenthesized.
</p>
</blockquote>

<p>
In the case of addition this point is somewhat moot.  The order in
which we group arguments does not affect the <i>value</i> of a sequence of
additions.  That is, addition is <b>associative</b>.
</p>

<blockquote>
<p>
<b>Definition.</b> An operator \(\circ: X \to X \to X\) is <b>associative</b> if
</p>

\begin{align*}
  (a \circ b) \circ c = a \circ (b \circ c)
\end{align*}

<p>
for any \(a\), \(b\), and \(c\) in \(X\).
</p>
</blockquote>

<p>
Not all operators are associative.  Take division for example.  We
need to <i>decide</i> how to implicitly parenthesize an expression like
</p>

\begin{align*}
a / b / c / d
\end{align*}

<p>
Again, we could try to bar the ability to write an expression like
this, but we might rather avoid using parentheses if possible.
</p>

<blockquote>
<p>
<b>Exercise.</b> How does OCaml evaluate the expression <code>100 / 5 / 4</code>?
How are arguments grouped?
</p>
</blockquote>

<p>
For binary operators, we typically choose one of the first two choices
in the list of parenthesizations above.
</p>

<blockquote>
<p>
<b>Definition.</b> A operation \(\circ : X \to X \to X\) is said to be
<b>left-associative</b> if sequences of applications of the operator are
understood as grouping arguments from the left, i.e.,
</p>

\begin{align*}
a \circ b \circ c \circ d = (((a \circ b) \circ c) \circ d)
\end{align*}
<p>
for any \(a\), \(b\), \(c\), and \(d\), in \(X\).  It's said to be
<b>right-associative</b> if arguments are grouped from the right, i.e.,
</p>

\begin{align*}
a \circ b \circ c \circ d = (a \circ (b \circ (c \circ d)))
\end{align*}
</blockquote>

<blockquote>
<p>
<b>Remark.</b> Another option is that a binary operator can have no
associativity.  It does not, for instance, make sense to apply a
sequence of <code>(=)</code> operators in OCaml.
</p>
</blockquote>

<p>
Bringing this back to grammatical ambiguity, giving a parenthesization
of a sequence of operators means specifying a "shape" for the
corresponding parse tree.  For example, taking addition to be
left-associative, i.e., taking <code>x + x + x</code> to mean <code>((x + x) + x)</code>,
implies that, of the two parse trees for this sentence in the above
image, the one on the right should be the "correct" one, <i>not</i> the
one on the left.
</p>

<blockquote>
<p>
<b>Example.</b> Another common ambiguous grammar in programming languages
is the one for function types.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">fun-type</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">int-type</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">fun-type</span>&gt; -&gt; &lt;<span style="color: #483d8b;">fun-type</span>&gt;
&lt;<span style="color: #0000ff;">int-type</span>&gt; <span style="color: #008b8b;">::=</span> int
</pre>
</div>
</blockquote>

<blockquote>
<p>
<b>Exercise.</b> Give two leftmost derivations of <code>int -&gt; int -&gt; int</code> in
 the above grammar.
</p>
</blockquote>

<blockquote>
<p>
<b>Aside.</b> Looking ahead a bit, we will end up building parsers using a
parser generator.  In this setting, specifying the associativity of an
operator will be simple: there will be a command for doing so, a line
we'll add to the code.  But we can also deal with associativity <i>in
the grammar itself.</i>
</p>

<p>
Function types are right associative, so we understand
</p>

<div class="org-src-container">
<pre class="src src-ty">int -&gt; int -&gt; int
</pre>
</div>

<p>
to be parenthesized implicitly as
</p>

<div class="org-src-container">
<pre class="src src-ty">int -&gt; (int -&gt; int)
</pre>
</div>

<p>
The problem, as it stands, is that because of the production rule
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">fun-type</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">fun-type</span>&gt; -&gt; &lt;<span style="color: #483d8b;">fun-type</span>&gt;
</pre>
</div>

<p>
the argument type can an arbitrary complex function type.  But we
might recognize that, no matter how deep the nesting, the argument
types have the special property in the case we assume right
associativity: <i>they're always just <code>int</code></i>.  Therefore, we
might consider the following updated grammar.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">fun-type</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">int-type</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">int-type</span>&gt; -&gt; &lt;<span style="color: #483d8b;">fun-type</span>&gt;
&lt;<span style="color: #0000ff;">int-type</span>&gt; <span style="color: #008b8b;">::=</span> int
</pre>
</div>

<p>
In this grammar, no matter how many times you apply the second
alternative of the first production rule, the argument type is always
just the <code>int</code> type.  So we were, in fact, able to restrict the shape
of the parse tree for sentences, by <b>breaking the symmetry</b> the
production rule.  (This, of course, is more complicated once we start
considering higher-order functions).
</p>
</blockquote>

<blockquote>
<p>
<b>Exercise.</b> Write the leftmost derivation of
</p>

<div class="org-src-container">
<pre class="src src-ty">int -&gt; int -&gt; int
</pre>
</div>

<p>
in the above grammar, along with its parse tree.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgf000be4" class="outline-3">
<h3 id="orgf000be4">Precedence</h3>
<div class="outline-text-3" id="text-orgf000be4">
<p>
In the examples from the previous section, there was only one operator.
In the presence of multiple operators we have new issues to deal with.
<i>How should something like \(x * y + z\) be implicitly parenthesized?</i>
</p>

<p>
This is an issue of <b>precedence</b> or <b>order of operations</b> something
probably already somewhat familiar to you.
</p>

<p>
If you went through the American public school system then you
probably learned the abbreviation PEMDAS ((P)arentheses,
(E)xponentiation, (M)ultiplication, (D)ivision, (A)ddition,
(S)ubtraction, along with an accompanying mnemonic, something like
"please excuse my dear aunt sally").  Focusing on just the last four
letters, this rule tells us that we should group multiplications and
divisions first, and then group additions and subtractions.  That is
to say, multiplication and division have greater <b>precedence</b> than
addition and subtraction.
</p>

<blockquote>
<p>
<b>Definition.</b> The <b>precedence</b> of an operator, relative to another
operator, determines which operator binds more tightly, in the
presents of ambiguity.
</p>
</blockquote>

<blockquote>
<p>
<b>Example.</b> The expression \(2 * 3 + 4 * 5\) should be implicitly
 parenthesized as \((2 * 3) + (4 * 5)\) because multiplication binds
 tighter, it is considered first.
</p>
</blockquote>


<p>
The relative precedence of a collection of operators determines the
"shape" of the parse tree we get when we generate the sentence with a
grammar.  To say that multiplication has higher precedence is to say
that when we build the parse tree for <code>x * x + x</code>, we want <code>+</code> to be
the top-level operation, at the root of the tree.
</p>


<blockquote>
<p>
<b>Remark.</b> One thing that was probably glossed over if/when you learned
PEMDAS: what do you do with something like \(1 + 1 - 1 + 1\)?  Do you
group additions and then subtractions? Or vice versa?  The issue here
is that addition and subtraction have the <i>same</i> precedence.  In this
case, we will use the associativity of the operators to determine how
to parenthesize: <b><b>given a sequences of operators of the same
precedence, we use their associativity to group them.</b></b>
</p>

<p>
Since addition and subtraction are both left-associative, this would
be parenthesized as \(((1 + 1) - 1) + 1\).  Things can get <i>truly</i> ugly
if you have two operators with the same precedence, but <i>different</i>
associativity.  We will ignore this possibility in this course, but
this really matters in languages like Haskell, in which users can
define their own operators, with specified precedence and
associativity.
</p>
</blockquote>

<p>
All of this is to say: in order to define an unambiguous grammar
without parentheses, we need to know three things of each operator
appearing in the grammar: <b>fixity</b>, <b>associativity</b>, and <b>precedence</b>.
Fixity is determined directly by the production rules, but we will
have to specify associativity and precedence explicitly.
</p>

<p>
We can, for example, present the four basic arithmetic operators along
with this information.  The operators are presented in order of
decreasing precedence.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Fixity</th>
<th scope="col" class="org-left">Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>*</code>, <code>/</code></td>
<td class="org-left">infix</td>
<td class="org-left">left</td>
</tr>

<tr>
<td class="org-left"><code>+</code>, <code>-</code></td>
<td class="org-left">infix</td>
<td class="org-left">left</td>
</tr>
</tbody>
</table>

<p>
In fact, just like the grammar for the OCaml is given in the OCaml
Manual, so is <a href="https://v2.ocaml.org/api/Ocaml_operators.html">the associativity and precedence of all its operators</a>.
</p>

<blockquote>
<p>
<b>Aside.</b> As with associativity, we will be able to specify precedence
the parser generator we use.  And, as with associativity, we can also
deal with precedence in the grammar itself.
</p>

<p>
In the case of arithmetic expressions, we use similar observations:
</p>
<ul class="org-ul">
<li>because of associativity, the right argument of multiplication or
division must be a variable <code>x</code>;</li>
<li>because of precedence, the left argument of multiplication or
division must contain only multiplications and divisions;</li>
<li>because of associativity, the right argument of addition or
subtraction must be an expression with only multiplications and
divisions.</li>
</ul>

<p>
These observations yields the following grammar.  I've tried to use
suggestive names to indicate how the three points above manifest.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt;         <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">add-sub</span>&gt; &lt;<span style="color: #483d8b;">only-mul-div</span>&gt;
&lt;<span style="color: #0000ff;">only-mul-div</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; &lt;<span style="color: #483d8b;">mul-div</span>&gt; &lt;<span style="color: #483d8b;">var</span>&gt;
&lt;<span style="color: #0000ff;">add-sub</span>&gt;      <span style="color: #008b8b;">::=</span> + <span style="color: #ff0000; font-weight: bold;">|</span> -
&lt;<span style="color: #0000ff;">mul-div</span>&gt;      <span style="color: #008b8b;">::=</span> * <span style="color: #ff0000; font-weight: bold;">|</span> /
&lt;<span style="color: #0000ff;">var</span>&gt;          <span style="color: #008b8b;">::=</span> x
</pre>
</div>
</blockquote>

<blockquote>
<p>
<b>Exercise.</b> Give the leftmost derivation of
</p>

<div class="org-src-container">
<pre class="src src-sent">x * x + x * x
</pre>
</div>

<p>
in the above grammar. Also draw its parse tree.
</p>
</blockquote>


<p>
Proving that this grammar is unambiguous is a bit tricky (we won't do
this).  It suffices to say that, given we know how to parenthesize
such expressions, and this grammar captures the rules we use, it would
seem to be ambiguous.
</p>
</div>
</div>

<div id="outline-container-org3348eb1" class="outline-3">
<h3 id="org3348eb1">Parentheses (Again)</h3>
<div class="outline-text-3" id="text-org3348eb1">
<p>
We're not quite done.  Without parentheses, we can't derive all
expressions we might want to write down.  This is important:
<b>parentheses in a programming language aren't just "there"
implicitly.  We have to explicitly include them in our grammar.</b>
</p>

<p>
Given the rules we've described above, we cannot write an expression
(without parentheses) which is equivalent to
</p>

<div class="org-src-container">
<pre class="src src-sent">(x + x) + x
</pre>
</div>

<p>
To give a complete specification of the arithmetic expressions we know
and love, we have to add back parentheses (this is the "P" part of
PEMDAS).
</p>

<p>
But where should we put parentheses into the grammar?  As we saw
above, if we put them everywhere, we get unnecessarily verbose
sentences.  Rather, it should be the case that: <i>it should be possible
put <b>any</b> expression as an argument to operator if it's wrapped in
parentheses.</i> For this we will replace <code>&lt;var&gt;</code> with something can also
be any expression wrapped in parentheses.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt;          <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">add-sub</span>&gt; &lt;<span style="color: #483d8b;">only-mul-div</span>&gt;
&lt;<span style="color: #0000ff;">only-mul-div</span>&gt;  <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-or-parens</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; &lt;<span style="color: #483d8b;">mul-div</span>&gt; &lt;<span style="color: #483d8b;">var-or-parens</span>&gt;
&lt;<span style="color: #0000ff;">add-sub</span>&gt;       <span style="color: #008b8b;">::=</span> + <span style="color: #ff0000; font-weight: bold;">|</span> -
&lt;<span style="color: #0000ff;">mul-div</span>&gt;       <span style="color: #008b8b;">::=</span> * <span style="color: #ff0000; font-weight: bold;">|</span> /
&lt;<span style="color: #0000ff;">var-or-parens</span>&gt; <span style="color: #008b8b;">::=</span> x <span style="color: #ff0000; font-weight: bold;">|</span> ( &lt;<span style="color: #483d8b;">expr</span>&gt; )
</pre>
</div>

<p>
We might worry that now, it is again possible to have an arbitrary
expression as an argument to an operator, but the point is that, if we
do this, it must be wrapped in parentheses, which ensures unambiguity.
</p>

<blockquote>
<p>
&gt; <b>Exercise.</b> Give a leftmost derivation of
</p>

<div class="org-src-container">
<pre class="src src-sent">( x + x ) * x
</pre>
</div>

<p>
in the above grammar. Draw its parse tree.
</p>
</blockquote>


<blockquote>
<p>
<b>Exercise.</b> (Challenge) According to PEMDAS, we also need to handle
exponentiation.  Give a grammar for arithmetic expressions including
parentheses and exponentiation, using the following operator
information.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Fixity</th>
<th scope="col" class="org-left">Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>^</code></td>
<td class="org-left">infix</td>
<td class="org-left">right</td>
</tr>

<tr>
<td class="org-left"><code>*</code>, <code>/</code></td>
<td class="org-left">infix</td>
<td class="org-left">left</td>
</tr>

<tr>
<td class="org-left"><code>+</code>, <code>-</code></td>
<td class="org-left">infix</td>
<td class="org-left">left</td>
</tr>
</tbody>
</table>
</blockquote>

<blockquote>
<p>
<b>Exercise.</b> (Challenge) Write a grammar for Boolean expressions in Python.  You
can check what sorts of expressions are allowed by using the Python
interpreter.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org9f37264" class="outline-2">
<h2 id="org9f37264">Extended BNF</h2>
<div class="outline-text-2" id="text-org9f37264">
<p>
There are a number of extensions to the BNF (meta-)syntax which make
it more usable.  If you go digging around the Internet for Extended
BNF (EBNF), you'll find a couple definitions, most of which are more
complex than what we will choose to call EBNF here.  That said, the
extensions we consider in this short section are the ones that will be
available in the parser generator we use in the next chapter.
</p>
</div>

<div id="outline-container-org3c33293" class="outline-3">
<h3 id="org3c33293">Optional</h3>
<div class="outline-text-3" id="text-org3c33293">
<p>
We use <code>[ SENT-FORM ]</code> to notate part of a production rule which is
optional.  We may, for instance, want to write a language which has
both if-then and if-then-else expressions.  Rather than using the BNF
production rules
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">if-expr</span>&gt; <span style="color: #008b8b;">::=</span> if &lt;<span style="color: #483d8b;">expr</span>&gt; then &lt;<span style="color: #483d8b;">expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> if &lt;<span style="color: #483d8b;">expr</span>&gt; then &lt;<span style="color: #483d8b;">expr</span>&gt; else &lt;<span style="color: #483d8b;">expr</span>&gt;
</pre>
</div>

<p>
we can use the EBNF production rule
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">if-expr</span>&gt; <span style="color: #008b8b;">::=</span> if &lt;<span style="color: #483d8b;">expr</span>&gt; then &lt;<span style="color: #483d8b;">expr</span>&gt; [ else &lt;<span style="color: #483d8b;">expr</span>&gt; ]
</pre>
</div>

<p>
These two rules express the same thing. In fact, <i>all BNF production
rules are also EBNF production rules, and all EBNF production rules
can be rewritten as a collection of BNF production rules.</i>
</p>

<blockquote>
<p>
<b>Exercise.</b> Rewrite the following EBNF production rule as a collection of BNF production rules.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">a</span>&gt; <span style="color: #008b8b;">::=</span> a [ &lt;<span style="color: #483d8b;">b</span>&gt; ] [ a ]
</pre>
</div>
</blockquote>

<blockquote>
<p>
<b>Remark.</b> One issue with extending BNF is now we've made it harder to
express grammars which include the symbols used for the EBNF
extensions (e.g., <code>[</code> and <code>]</code>).  In practice this is not a problem, we
will try to be very explicit if something like <code>[</code> appears as part of
a symbol of the grammar, and not a part of the specification of the
grammar.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgaf5667b" class="outline-3">
<h3 id="orgaf5667b">Alternative</h3>
<div class="outline-text-3" id="text-orgaf5667b">
<p>
We use <code>( SENT-FORM₁ | SENT-FORM₂ | ... | SENT-FORMₖ )</code> to notate the
choice of multiple sentential forms as <i>part</i> of a production rule.
In the previous section we defined a grammar for arithmetic
expressions with multiple rules for the choice of operation.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt;          <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">add-sub</span>&gt; &lt;<span style="color: #483d8b;">only-mul-div</span>&gt;
&lt;<span style="color: #0000ff;">only-mul-div</span>&gt;  <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-or-parens</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; &lt;<span style="color: #483d8b;">mul-div</span>&gt; &lt;<span style="color: #483d8b;">var-or-parens</span>&gt;
&lt;<span style="color: #0000ff;">add-sub</span>&gt;       <span style="color: #008b8b;">::=</span> + <span style="color: #ff0000; font-weight: bold;">|</span> -
&lt;<span style="color: #0000ff;">mul-div</span>&gt;       <span style="color: #008b8b;">::=</span> * <span style="color: #ff0000; font-weight: bold;">|</span> /
&lt;<span style="color: #0000ff;">var-or-parens</span>&gt; <span style="color: #008b8b;">::=</span> x <span style="color: #ff0000; font-weight: bold;">|</span> ( &lt;<span style="color: #483d8b;">expr</span>&gt; )
</pre>
</div>

<p>
We can simplify this in EBNF by removing the production rules for operators.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt;          <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; (+ <span style="color: #ff0000; font-weight: bold;">|</span> -)  &lt;<span style="color: #483d8b;">only-mul-div</span>&gt;
&lt;<span style="color: #0000ff;">only-mul-div</span>&gt;  <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-or-parens</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; (* <span style="color: #ff0000; font-weight: bold;">|</span> /) &lt;<span style="color: #483d8b;">var-or-parens</span>&gt;
&lt;<span style="color: #0000ff;">var-or-parens</span>&gt; <span style="color: #008b8b;">::=</span> x <span style="color: #ff0000; font-weight: bold;">|</span> ( &lt;<span style="color: #483d8b;">expr</span>&gt; )
</pre>
</div>
</div>
</div>

<div id="outline-container-org8672d52" class="outline-3">
<h3 id="org8672d52">Repetition</h3>
<div class="outline-text-3" id="text-org8672d52">
<p>
We use <code>{ SENT-FORM }</code> to notate a part of a production rule which can
be repeated as many times as we want.  We can also combine this with
the alternative notation to as
</p>

<div class="org-src-container">
<pre class="src src-bnf">{ SENT-FORM&#8321; <span style="color: #ff0000; font-weight: bold;">|</span> SENT-FORM&#8322; <span style="color: #ff0000; font-weight: bold;">|</span> ... <span style="color: #ff0000; font-weight: bold;">|</span> SENT-FORM&#8342; }
</pre>
</div>

<p>
to represent a collection of choices we may repeat as many times as we
want.
</p>

<p>
In the same grammar as above, we can rewrite the recursive production
rules in terms of repetition.
</p>

<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt;          <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; { (+ <span style="color: #ff0000; font-weight: bold;">|</span> -) &lt;<span style="color: #483d8b;">only-mul-div</span>&gt; }
&lt;<span style="color: #0000ff;">only-mul-div</span>&gt;  <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-or-parens</span>&gt; { (* <span style="color: #ff0000; font-weight: bold;">|</span> /) &lt;<span style="color: #483d8b;">var-or-parens</span>&gt; }
&lt;<span style="color: #0000ff;">var-or-parens</span>&gt; <span style="color: #008b8b;">::=</span> x <span style="color: #ff0000; font-weight: bold;">|</span> ( &lt;<span style="color: #483d8b;">expr</span>&gt; )
</pre>
</div>

<blockquote>
<p>
<b>Exercise.</b> (Challenge) Write an EBNF specification for Boolean
 expressions in Python.
</p>
</blockquote>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">It can be used as a prefix operator if put in
parentheses, e.g. <code>(+) x 1</code>, but it cannot in any circumstances be
used as a postfix operator.  We will discuss fixity in more detail
later.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This
sentence is taken from the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Syntactic_ambiguity">syntactic ambiguity</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">We can only present the table like this
because we assume that all operators of the same precedence also have
the same fixity.</p></div></div>


</div>
</div></div>
</body>
</html>
