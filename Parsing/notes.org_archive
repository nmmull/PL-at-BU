#    -*- mode: org -*-


Archived entries from file /Users/NathanM/Developer/Repositories/nmmull.github.io/PL-at-BU/Parsing/notes.org


* Using Menhir
:PROPERTIES:
:ARCHIVE_TIME: 2024-10-20 Sun 12:23
:ARCHIVE_FILE: ~/Developer/Repositories/nmmull.github.io/PL-at-BU/Parsing/notes.org
:ARCHIVE_CATEGORY: notes
:END:

With that business out of the way, we go to generating a parser for a
simple expression language using Menhir.  We always start with a
grammar, and a table which tells us the precedence of some operators
represented in the grammar.

This will be our working example, a language for arithmetic
expressions with local variables.

#+begin_src bnf
   <prog>  ::= <expr> EOF

   <expr>  ::= 'let' <var> '=' <expr> 'in' <expr>
	     | <expr1>

   <expr1> ::= <expr1> '+' <expr1>
	     | <expr1> '-' <expr1>
	     | <expr1> '*' <expr1>
	     | <expr1> '/' <expr1>
	     | <num>
	     | <var>
	     | '(' <expr> ')'

   <num> ::= '0'
   <var> ::= 'x'

   ; num = '-'? ['0'-'9']+
   ; var = ['a'-'z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_' '\'']*
#+end_src

Operator associativity in order of increasing precedence:
| Operator | Associativity |
|----------+---------------|
| ~+~, ~-~ | left          |
| ~*~, ~/~ | left          |

** Step 0: The Project File
If we want to use Menhir, we have to tell dune.  Add the stanza

#+begin_src dune
(using menhir 2.1)
#+end_src

to the end of the file ~dune-project~.
** Step 1: Setting Up

You need to define 5 files.

#+begin_src ascii
  lib
  └──parser
     ├──ast.ml
     ├──dune
     ├──lex.mll
     ├──my_parser.ml
     └──par.mly
#+end_src
For this course, ~dune~ and ~my_parser.ml~ are fixed:

~dune~:
#+begin_src dune
  (library (name my_parser))
  (menhir (modules par))
  (ocamllex lex)
#+end_src

~my_parser.ml:~
#+begin_src ocaml
  let parse s =
    try Some (Parser.prog Lexer.read (Lexing.from_string s))
    with _ -> None
#+end_src

One of the benefits of using a parser generator is better error
messages.  We will /not/ be using this feature in this course.  If you
were to use Menhir in a personal project, you would need to update the
~parse~ function to make use of the exceptions produced by
~Parser.prog~.

The last three files are where the work happens.

We can start with the following dummy files.

~ast.ml~:
#+begin_src ocaml
  type prog = unit
#+end_src

~lex.mll~:
#+begin_src mll
  {
  open Par
  }

  rule read =
    parse
    | eof { EOF }
#+end_src

~par.mly~
#+begin_src mly
  %{
  open Ast
  %}

  %token EOF

  %start <Ast.prog> { prog }

  %%

  prog:
    | EOF { () }
#+end_src
** Step 2: Ast
** Step 3: Token
** Step 4: Lexer
** Step 5: Parser
