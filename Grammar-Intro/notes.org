#+title: Introduction
#+HTML_MATHJAX: align: left indent: 2em
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../myStyle.css" />
#+OPTIONS: html-style:nil H:2 toc:1 num:nil tasks:nil
#+HTML_LINK_HOME: ../toc.html

Most of us are familiar with grammar in the context of natural
language.  In English class, we learn that we should use the article
"an" instead of "a" if its corresponding noun starts with a vowel
sound, and that what follows a semicolon should be a independent
clause (i.e., should be able to stand on its own as a complete
sentences).  These are examples of English /grammar rules/.

Grammar, in broad strokes, refers to the rules which govern what
constitutes a well-formed sentence in a given language, barring
low-level syntactic concerns like spelling or whitespace.  It's the
concern of grammar to determine that


#+begin_src sentence
I taught the car in the refrigerator
#+end_src

makes grammatical sense and that

#+begin_src sentence
I car teach refrigerator in there
#+end_src

does not.  It's /not/ the concern of grammar to determine that the
first sentence, though grammatical, has no reasonable interpretation
in English (except, perhaps, in surrealist fiction).

Programming languages──being themselves languages in their own right,
albeit more stringent ones than natural languages──have their own
grammars, i.e., rules for determining what counts as a well-formed
/program/.  Due to the grammatic precision expected of programming
languages (we don't want too much variation in what we are allowed to
write as a valid program), these tend to be called *formal grammars*.

#+begin_quote
*Example.* In OCaml, the program

#+begin_src ocaml
  let f x = x + 1
#+end_src

is well-formed, but the program

#+begin_src ocaml
  let f x = x 1 +
#+end_src

is not, because the rule for using the ~+~ operator is that its
arguments appear to its left and its right, i.e., it's an /infix
operator/.[fn::It can be used as a prefix operator if put in
parentheses, e.g. ~(+) x 1~, but it cannot in any circumstances be
used as a postfix operator.  We will discuss fixity in more detail
later.]
#+end_quote

As in the case of natural language, grammars for programming languages
are not concerned with the *meaning* of programs, just their
well-formedness. The program


#+begin_src ocaml
  let omega x = x x
#+end_src

is well-formed in OCaml, but it's not well-typed since the argument
~x~ is expected to be a function of type ~'a -> 'b~ as well as an
argument of type ~'a~, an impossibility in the type system of OCaml.

If our goal is to interpret computer programs, then we have to
understand formally──both theoretically and practically──the grammars
describing the well-formed programs.  This means being able to
represent and interpret representations of formal grammars.  The
grammar of OCaml, for example, is given in its entirety in [[https://v2.ocaml.org/manual/expr.html][The OCaml
Manual]].  After going through this chapter, you should be able to
interpret the specification given there.

Placing this in the pipeline of interpretation, a grammar represents
the target of /parsing/.  As a reminder, a stream of tokens is parsed
into a *parse tree*, a hierarchical structure which describes the way
the program is formally composed.  It's easier to determine the meaning
of a program (i.e., to interpret it) given its hierarchical structure
as opposed to its linear form as a stream of tokens.

#+begin_quote
*Remark.* This is another way of conceptualizing the role of grammar:
it determines the hierarchical structure of a sentence.  A sentence
may be considered well-formed if it can constructed as well-formed
parse tree, e.g.

#+begin_src ascii
  S
  ├──┐
  │  VP
  │  ├──────┐
  │  │      NP
  │  │      ├───────┐
  │  │      │       PP
  │  │      │       ├──┐
  NP │      NP      │  NP
  │  │      ├───┐   │  ├───┐
  N  V      A   N   P  A   N
  │  │      │   │   │  │   │
  I  taught the car in the refrigerator.
#+end_src
#+end_quote

Its not important that you know exactly what you each of the
abbreviations in the above image stand for (this isn't a linguistics
course, but hopefully we can make educated guesses) but hopefully the
structure aligns with your intuition about how words in the sentences
are grouped.

In this collection of notes on formal grammars, we will:

+ define *Backus-Naur Form* specifications, a way of describing
  so-called *context-free grammars*, which we will use to present the
  grammars of programming languages;
+ discuss *ambiguity* in grammar along with how to avoid it (and why);
+ Look at *Extended BNF* as a slightly more useful framework for
  specifying programming languages.
